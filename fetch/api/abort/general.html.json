{"status":"TIMEOUT","subtests":[{"name":"Window: Aborting rejects with AbortError","status":"FAIL"},{"name":"Window: Aborting rejects with AbortError - no-cors","status":"FAIL"},{"name":"Window: Request objects have a signal property","status":"FAIL"},{"name":"Window: Signal on request object","status":"FAIL"},{"name":"Window: Signal on request object created from request object","status":"FAIL"},{"name":"Window: Signal on request object created from request object, with signal on second request","status":"FAIL"},{"name":"Window: Signal on request object created from request object, with signal on second request overriding another","status":"FAIL"},{"name":"Window: Signal retained after unrelated properties are overridden by fetch","status":"FAIL"},{"name":"Window: Signal removed by setting to null","status":"FAIL"},{"name":"Window: Already aborted signal rejects immediately","status":"FAIL"},{"name":"Window: Request is still 'used' if signal is aborted before fetching","status":"FAIL"},{"name":"Window: response.arrayBuffer() rejects if already aborted","status":"FAIL"},{"name":"Window: response.blob() rejects if already aborted","status":"FAIL"},{"name":"Window: response.formData() rejects if already aborted","status":"FAIL"},{"name":"Window: response.json() rejects if already aborted","status":"FAIL"},{"name":"Window: response.text() rejects if already aborted","status":"FAIL"},{"name":"Window: Already aborted signal does not make request","status":"FAIL"},{"name":"Window: Already aborted signal can be used for many fetches","status":"FAIL"},{"name":"Window: Signal can be used to abort other fetches, even if another fetch succeeded before aborting","status":"FAIL"},{"name":"Window: Underlying connection is closed when aborting after receiving response","status":"FAIL"},{"name":"Window: Underlying connection is closed when aborting after receiving response - no-cors","status":"FAIL"},{"name":"Window: Fetch aborted & connection closed when aborted after calling response.arrayBuffer()","status":"FAIL"},{"name":"Window: Fetch aborted & connection closed when aborted after calling response.blob()","status":"FAIL"},{"name":"Window: Fetch aborted & connection closed when aborted after calling response.formData()","status":"FAIL"},{"name":"Window: Fetch aborted & connection closed when aborted after calling response.json()","status":"FAIL"},{"name":"Window: Fetch aborted & connection closed when aborted after calling response.text()","status":"FAIL"},{"name":"Window: Stream errors once aborted. Underlying connection closed.","status":"FAIL"},{"name":"Window: Stream errors once aborted, after reading. Underlying connection closed.","status":"FAIL"},{"name":"Window: Stream will not error if body is empty. It's closed with an empty queue before it errors.","status":"FAIL"},{"name":"Window: Readable stream synchronously cancels with AbortError if aborted before reading","status":"FAIL"},{"name":"DedicatedWorkerGlobalScope: Aborting rejects with AbortError","status":"FAIL"},{"name":"DedicatedWorkerGlobalScope: Aborting rejects with AbortError - no-cors","status":"FAIL"},{"name":"DedicatedWorkerGlobalScope: Request objects have a signal property","status":"FAIL"},{"name":"DedicatedWorkerGlobalScope: Signal on request object","status":"FAIL"},{"name":"DedicatedWorkerGlobalScope: Signal on request object created from request object","status":"FAIL"},{"name":"DedicatedWorkerGlobalScope: Signal on request object created from request object, with signal on second request","status":"FAIL"},{"name":"DedicatedWorkerGlobalScope: Signal on request object created from request object, with signal on second request overriding another","status":"FAIL"},{"name":"DedicatedWorkerGlobalScope: Signal retained after unrelated properties are overridden by fetch","status":"FAIL"},{"name":"DedicatedWorkerGlobalScope: Signal removed by setting to null","status":"FAIL"},{"name":"DedicatedWorkerGlobalScope: Already aborted signal rejects immediately","status":"FAIL"},{"name":"DedicatedWorkerGlobalScope: Request is still 'used' if signal is aborted before fetching","status":"FAIL"},{"name":"DedicatedWorkerGlobalScope: response.arrayBuffer() rejects if already aborted","status":"FAIL"},{"name":"DedicatedWorkerGlobalScope: response.blob() rejects if already aborted","status":"FAIL"},{"name":"DedicatedWorkerGlobalScope: response.formData() rejects if already aborted","status":"FAIL"},{"name":"DedicatedWorkerGlobalScope: response.json() rejects if already aborted","status":"FAIL"},{"name":"DedicatedWorkerGlobalScope: response.text() rejects if already aborted","status":"FAIL"},{"name":"DedicatedWorkerGlobalScope: Already aborted signal does not make request","status":"FAIL"},{"name":"DedicatedWorkerGlobalScope: Already aborted signal can be used for many fetches","status":"FAIL"},{"name":"DedicatedWorkerGlobalScope: Signal can be used to abort other fetches, even if another fetch succeeded before aborting","status":"FAIL"},{"name":"DedicatedWorkerGlobalScope: Underlying connection is closed when aborting after receiving response","status":"FAIL"},{"name":"DedicatedWorkerGlobalScope: Underlying connection is closed when aborting after receiving response - no-cors","status":"FAIL"},{"name":"DedicatedWorkerGlobalScope: Fetch aborted & connection closed when aborted after calling response.arrayBuffer()","status":"FAIL"},{"name":"DedicatedWorkerGlobalScope: Fetch aborted & connection closed when aborted after calling response.blob()","status":"FAIL"},{"name":"DedicatedWorkerGlobalScope: Fetch aborted & connection closed when aborted after calling response.formData()","status":"FAIL"},{"name":"DedicatedWorkerGlobalScope: Fetch aborted & connection closed when aborted after calling response.json()","status":"FAIL"},{"name":"DedicatedWorkerGlobalScope: Fetch aborted & connection closed when aborted after calling response.text()","status":"FAIL"},{"name":"DedicatedWorkerGlobalScope: Stream errors once aborted. Underlying connection closed.","status":"FAIL"},{"name":"DedicatedWorkerGlobalScope: Stream errors once aborted, after reading. Underlying connection closed.","status":"FAIL"},{"name":"DedicatedWorkerGlobalScope: Stream will not error if body is empty. It's closed with an empty queue before it errors.","status":"FAIL"},{"name":"DedicatedWorkerGlobalScope: Readable stream synchronously cancels with AbortError if aborted before reading","status":"FAIL"},{"name":"SharedWorkerGlobalScope: Aborting rejects with AbortError","status":"FAIL"},{"name":"SharedWorkerGlobalScope: Aborting rejects with AbortError - no-cors","status":"FAIL"},{"name":"SharedWorkerGlobalScope: Request objects have a signal property","status":"FAIL"},{"name":"SharedWorkerGlobalScope: Signal on request object","status":"FAIL"},{"name":"SharedWorkerGlobalScope: Signal on request object created from request object","status":"FAIL"},{"name":"SharedWorkerGlobalScope: Signal on request object created from request object, with signal on second request","status":"FAIL"},{"name":"SharedWorkerGlobalScope: Signal on request object created from request object, with signal on second request overriding another","status":"FAIL"},{"name":"SharedWorkerGlobalScope: Signal retained after unrelated properties are overridden by fetch","status":"FAIL"},{"name":"SharedWorkerGlobalScope: Signal removed by setting to null","status":"FAIL"},{"name":"SharedWorkerGlobalScope: Already aborted signal rejects immediately","status":"FAIL"},{"name":"SharedWorkerGlobalScope: Request is still 'used' if signal is aborted before fetching","status":"FAIL"},{"name":"SharedWorkerGlobalScope: response.arrayBuffer() rejects if already aborted","status":"FAIL"},{"name":"SharedWorkerGlobalScope: response.blob() rejects if already aborted","status":"FAIL"},{"name":"SharedWorkerGlobalScope: response.formData() rejects if already aborted","status":"FAIL"},{"name":"SharedWorkerGlobalScope: response.json() rejects if already aborted","status":"FAIL"},{"name":"SharedWorkerGlobalScope: response.text() rejects if already aborted","status":"FAIL"},{"name":"SharedWorkerGlobalScope: Already aborted signal does not make request","status":"FAIL"},{"name":"SharedWorkerGlobalScope: Already aborted signal can be used for many fetches","status":"FAIL"},{"name":"SharedWorkerGlobalScope: Signal can be used to abort other fetches, even if another fetch succeeded before aborting","status":"FAIL"},{"name":"SharedWorkerGlobalScope: Underlying connection is closed when aborting after receiving response","status":"FAIL"},{"name":"SharedWorkerGlobalScope: Underlying connection is closed when aborting after receiving response - no-cors","status":"FAIL"},{"name":"SharedWorkerGlobalScope: Fetch aborted & connection closed when aborted after calling response.arrayBuffer()","status":"FAIL"},{"name":"SharedWorkerGlobalScope: Fetch aborted & connection closed when aborted after calling response.blob()","status":"FAIL"},{"name":"SharedWorkerGlobalScope: Fetch aborted & connection closed when aborted after calling response.formData()","status":"FAIL"},{"name":"SharedWorkerGlobalScope: Fetch aborted & connection closed when aborted after calling response.json()","status":"FAIL"},{"name":"SharedWorkerGlobalScope: Fetch aborted & connection closed when aborted after calling response.text()","status":"FAIL"},{"name":"SharedWorkerGlobalScope: Stream errors once aborted. Underlying connection closed.","status":"FAIL"},{"name":"SharedWorkerGlobalScope: Stream errors once aborted, after reading. Underlying connection closed.","status":"FAIL"},{"name":"SharedWorkerGlobalScope: Stream will not error if body is empty. It's closed with an empty queue before it errors.","status":"FAIL"},{"name":"SharedWorkerGlobalScope: Readable stream synchronously cancels with AbortError if aborted before reading","status":"FAIL"}]}