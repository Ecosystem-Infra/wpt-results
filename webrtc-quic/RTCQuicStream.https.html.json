{"status":"OK","subtests":[{"name":"createStream() returns an RTCQuicStream with initial properties set.","status":"PASS"},{"name":"createStream() throws if the transport is not connected.","status":"PASS"},{"name":"createStream() throws if the transport is closed.","status":"PASS"},{"name":"RTCQuicTransport.stop() closes all local streams.","status":"PASS"},{"name":"RTCQuicTransport.stop() closes all remote streams.","status":"PASS"},{"name":"write() with a finish changes state to 'closing'.","status":"PASS"},{"name":"write() with a finish and an empty array changes state to 'closing'.","status":"PASS"},{"name":"write() with finish twice throws InvalidStateError.","status":"PASS"},{"name":"reset() changes state to 'closed'.","status":"PASS"},{"name":"reset() following write with finish changes state to 'closed'.","status":"PASS"},{"name":"createStream() followed by reset() fires a quicstream event followed by a statechange event to 'closed' on the remote side.","status":"PASS"},{"name":"waitForReadable() promise resolves with remote finish","status":"PASS"},{"name":"write() with a finish on a stream that has already read out finish changes state to 'closed'.","status":"PASS"},{"name":"Reading out finish on stream that has already called write() with a finish  state to 'closed'.","status":"PASS"},{"name":"Reading out finish then a getting a remote reset fires a statechange event to 'closed'.","status":"PASS"},{"name":"write() without finish and an empty array throws NotSupportedError.","status":"PASS"},{"name":"write() without finish and no data throws NotSupportedError.","status":"PASS"},{"name":"write() adds to writeBufferedAmount each call.","status":"PASS"},{"name":"write() data with a finish adds to writeBufferedAmount.","status":"PASS"},{"name":"write() can write exactly maxWriteBufferedAmount.","status":"PASS"},{"name":"write() throws if data longer than maxWriteBufferedAmount.","status":"PASS"},{"name":"write() throws if total write buffered amount would be greater than maxWriteBufferedAmount.","status":"PASS"},{"name":"write() causes quicstream event to fire on the remote transport.","status":"PASS"},{"name":"write() with a finish causes quicstream event to fire on the remote transport.","status":"PASS"},{"name":"write() throws InvalidStateError if write() with finish has been called.","status":"PASS"},{"name":"Stream closed by local reset(): write() throws InvalidStateError.","status":"PASS"},{"name":"Stream closed by remote reset(): write() throws InvalidStateError.","status":"PASS"},{"name":"Stream closed by writing a finish, followed by reading remote finish: write() throws InvalidStateError.","status":"PASS"},{"name":"Stream closed by by reading remote finish, followed by writing a finish: write() throws InvalidStateError.","status":"PASS"},{"name":"Stream closed by local RTCQuicTransport stop(): write() throws InvalidStateError.","status":"PASS"},{"name":"Stream closed by remote RTCQuicTransport stop(): write() throws InvalidStateError.","status":"PASS"},{"name":"readBufferedAmount set to 0 after local reset().","status":"PASS"},{"name":"readBufferedAmount set to 0 after remote reset().","status":"PASS"},{"name":"writeBufferedAmount set to 0 after local reset().","status":"PASS"},{"name":"writeBufferedAmount set to 0 after reading remote finish, followed by write() with finish.","status":"PASS"},{"name":"writeBufferedAmount set to 0 after local RTCQuicTransport stop().","status":"PASS"},{"name":"writeBufferedAmount maintained after write() with finish has been called.","status":"PASS"},{"name":"waitForWriteBufferedAmountBelow(0) resolves immediately.","status":"PASS"},{"name":"waitForWriteBufferedAmountBelow(maxWriteBufferedAmount) resolves immediately.","status":"PASS"},{"name":"Pending waitForWriteBufferedAmountBelow() promises rejected after write() with finish.","status":"PASS"},{"name":"waitForWriteBufferedAmountBelow() promises immediately rejected after wrote finish.","status":"PASS"},{"name":"Pending waitForWriteBufferedAmountBelow() promises rejected after reset().","status":"PASS"},{"name":"Pending waitForWriteBufferedAmountBelow() promises rejected after RTCQuicTransport stop().","status":"PASS"},{"name":"Stream closed by local reset(): waitForWriteBufferedBelow() rejects with InvalidStateError.","status":"PASS"},{"name":"Stream closed by remote reset(): waitForWriteBufferedBelow() rejects with InvalidStateError.","status":"PASS"},{"name":"Stream closed by writing a finish, followed by reading remote finish: waitForWriteBufferedBelow() rejects with InvalidStateError.","status":"PASS"},{"name":"Stream closed by by reading remote finish, followed by writing a finish: waitForWriteBufferedBelow() rejects with InvalidStateError.","status":"PASS"},{"name":"Stream closed by local RTCQuicTransport stop(): waitForWriteBufferedBelow() rejects with InvalidStateError.","status":"PASS"},{"name":"Stream closed by remote RTCQuicTransport stop(): waitForWriteBufferedBelow() rejects with InvalidStateError.","status":"PASS"},{"name":"readInto() on new local stream returns amount 0.","status":"PASS"},{"name":"Stream closed by local reset(): readInto() throws InvalidStateError.","status":"PASS"},{"name":"Stream closed by remote reset(): readInto() throws InvalidStateError.","status":"PASS"},{"name":"Stream closed by writing a finish, followed by reading remote finish: readInto() throws InvalidStateError.","status":"PASS"},{"name":"Stream closed by by reading remote finish, followed by writing a finish: readInto() throws InvalidStateError.","status":"PASS"},{"name":"Stream closed by local RTCQuicTransport stop(): readInto() throws InvalidStateError.","status":"PASS"},{"name":"Stream closed by remote RTCQuicTransport stop(): readInto() throws InvalidStateError.","status":"PASS"},{"name":"Read 1 byte.","status":"PASS"},{"name":"readInto() reads out finish after reading all data.","status":"PASS"},{"name":"waitForReadable() resolves with write() with finish.","status":"PASS"},{"name":"waitForReadable() resolves early if remote finish is received.","status":"PASS"},{"name":"waitForReadable() rejects with TypeError if amount is more than maxReadBufferedAmount.","status":"PASS"},{"name":"waitForReadable() promises immediately rejected with InvalidStateError after finish is read out.","status":"PASS"},{"name":"Pending waitForReadable() promises rejected after reset().","status":"PASS"},{"name":"Pending waitForReadable() promises rejected after remote reset().","status":"PASS"},{"name":"Pending waitForReadable() promises rejected after RTCQuicTransport stop().","status":"PASS"},{"name":"Pending waitForReadable() promises rejected after remote RTCQuicTransport stop().","status":"PASS"},{"name":"Stream closed by local reset(): waitForReadable() rejects with InvalidStateError.","status":"PASS"},{"name":"Stream closed by remote reset(): waitForReadable() rejects with InvalidStateError.","status":"PASS"},{"name":"Stream closed by writing a finish, followed by reading remote finish: waitForReadable() rejects with InvalidStateError.","status":"PASS"},{"name":"Stream closed by by reading remote finish, followed by writing a finish: waitForReadable() rejects with InvalidStateError.","status":"PASS"},{"name":"Stream closed by local RTCQuicTransport stop(): waitForReadable() rejects with InvalidStateError.","status":"PASS"},{"name":"Stream closed by remote RTCQuicTransport stop(): waitForReadable() rejects with InvalidStateError.","status":"PASS"}]}